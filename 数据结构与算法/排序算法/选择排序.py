"""
排序算法的稳定性介绍:
    概述:
        排序算法 = 把一串数据按照升序 或者 降序进行排列的 方式, 方法, 思维.
    分类:
        稳定排序算法:
            排序后, 相同元素的相对位置 不发生改变.
        不稳定排序算法:
            排序后, 相同元素的相对位置 发生改变.
    举例:
        不稳定排序算法: 选择排序, 快速排序...
        稳定排序算法:   冒泡排序, 插入排序...

选择排序介绍:
    原理:
        假设第1个元素为最小值, 定义变量min_index用于记录剩下元素中, 最小值的索引, 第一轮比较完毕后, 如果min_index的位置发生改变, 交换变量即可.
        即: 第1轮比较完毕后, 最小值就在最小索引处.
        大白话: 每轮比较完毕后, 最小值就在最小索引处.
    核心:
        1. 比较的总轮数.      列表的长度 - 1
        2. 每轮比较的总次数.   i + 1 ~ 列表的长度 - 1
        3. 谁和谁比较.        min_index 和 j 索引的元素.
    分析流程, 假设元素个数为5个, 具体如下:  [5, 3, 4, 7, 2]  -> 长度为: 5
        比较的轮数, i        每轮具体哪两个元素比较:        每轮比较的次数, j
        第1轮,索引:0          0和1, 0和2, 0和3, 0和4          4
        第2轮,索引:1          1和2, 1和3, 1和4               3
        第3轮,索引:2          2和3, 2和4                     2
        第4轮,索引:3          3和4                           1
总结:
    选择排序属于 不稳定排序算法, 最优时间复杂度: O(n²), 最坏时间复杂度: O(n²)
"""

# step1: 定义函数 select_sort(my_list), 对传入的列表元素进行排序.
def select_sort(my_list):
    n = len(my_list)
    # 2. 定义外循环, 表示: 比较的轮数.
    for i in range(n - 1):
        # 细节1: 定义变量, min_index, 用于记录: 本轮最小值的具体索引.
        min_index = i  # 假设每轮的起始值, 都是本轮的最小值.
        for j in range(i + 1, n):
            # 4. 如果当前的元素值 比 min_index记录的元素值还小, 就用min_index 记录当前值的索引.
            if my_list[j] < my_list[min_index]:
                min_index = j
            # 细节2: 走到这里, 说明一轮执行完毕, 判断min_index的索引值是否发生改变, 改变了, 就意味着: 当前元素不是最小值, 交换即可.
            if min_index != i:
                my_list[min_index], my_list[i] = my_list[i], my_list[min_index]


# step2: 具体的测试动作.
my_list = [5, 3, 4, 7, 2]
# my_list = [2, 3, 4, 5, 7]
# my_list = [5, 2, 3, 4, 7]

print(f"排序前: {my_list}")
# 排序动作.
select_sort(my_list)
print(f'排序后: {my_list}')
