'''
冒泡排序介绍:
    原理:
        相邻元素两两比较, 大的往后走, 这样第1轮比较完毕后, 最大值就在最大索引处.
        重复该动作, 直至排序完毕.
    核心:
        1. 比较的总轮数.      列表的长度 - 1
        2. 每轮比较的总次数.   列表的长度 - 1 - 当前轮数的索引
        3. 谁和谁比较.        my_list[j] 和 my_list[j + 1]
    分析流程, 假设元素个数为5个, 具体如下:  [5, 3, 4, 7, 2]  -> 长度为: 5
        比较的轮数, i        每轮比较的次数, j
        第1轮,索引:0          4 -> 5 - 1 - 0
        第2轮,索引:1          3 -> 5 - 1 - 1
        第3轮,索引:2          2 -> 5 - 1 - 2
        第4轮,索引:3          1 -> 5 - 1 - 3
总结:
    冒泡排序属于 稳定排序算法, 最优时间复杂度: O(n), 最坏时间复杂度: O(n²)
'''


def bubble_sort(my_list):
    # 1.获取列表长度
    n = len(my_list)
    # 2.定义循环，外循环控制比较轮数
    for i in range(n - 1):  # 因为两两比较，n个元素最多比较n-1次
        print(f'第 {i+1} 轮')
        # 改造1：定义变量,记录每轮的交换次数
        count = 0
        # 3.内层循环，每轮比较的次数
        for j in range(n - 1 - i):  # todo 每轮比较完后，会把本轮比较的最大值放到最后，所以下一轮比较就会少比较一个元素
            # 4.具体的比较的元素，相邻元素两两比较
            if my_list[j] > my_list[j + 1]:
                # 改造2：走这里说明两元素发生了交换,count+1
                count += 1
                my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]
        # 改造3:判断本轮是否发生交换，如无交换，说明已经排好序
        if count == 0:
            break



my_list = [5, 3, 4, 7, 2]
bubble_sort(my_list)
print(my_list)

